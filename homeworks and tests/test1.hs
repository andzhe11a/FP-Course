{-
Задача 1. Да се напише функция, която по даден списък от точки в декартовата равнина да намира координатите на горния ляв ъгъл на най-малкия (по площ) правоъгълник, който съдържа всички точки от списъка.

Задача 2. Да се напише функция, която за даден символен низ, съдържащ само латински букви и интервали, да намира броя на думите, започващи с главна буква. “Дума” дефинираме като последователност от букви, отделени от останалите символи с интервал или краищата на низа.

Задача 3. Едно положително цяло число ще наричаме съвършено, ако е равно на сумата от своите делители (без самото число). Например: 6 е съвършено, защото 6 = 1+2+3, а числото 9 не е съвършено (1+3 ≠ 9). Да се дефинира функция, която проверява дали дадено положително цяло число е съвършено.
(Бонус): Да се състави списък от всички съвършени числа.

Задача 4. Да се напише функция, която приема списък xs :: [a] и стойност x :: a и построява списък с поредните номера на елементите на xs, които съвпадат с x.

Задача 5. Дадени са списък от двойки xs :: [(a,a)] и списък choice :: [Bool]. За всеки елемент от x :: (a,a) от xs, съответния му елемент (като поредност) ch :: Bool от choice определя дали се интересуваме от първия или втория елемент на x. Ако ch е истина, вземаме първия компонент на x, а в противен случай - втория. Да се напише функция, която при подадени списъци xs и choice построява списък [a] по горното правило.

Задача 6. Да се дефинира функция, която приема списък [a] и заменя всички непрекъснати последователности от еднакви елементи x с единичен елемент x.
-}

import Data.Char
import Data.List

--ex1
task1 :: Ord a => [(a, a)] -> (a, a)
task1 ps = (minimum (map fst ps), maximum (map snd ps))

--ex2
task2 :: String -> Int
task2 str = length (filter (\x -> isUpper (head x)) (words str))

--ex3
task3 :: Int -> Bool
task3 n = n == sum [d | d <- [1..n-1], n `mod` d == 0]

bonusTask3 :: [Int]
bonusTask3 = filter task3 [1..]

--ex4
task4 :: Eq a => [a] -> a -> [Int]
task4 xs x = [i | (xi, i) <- zip xs [0..], xi == x]

--ex5
task5 :: [(a, a)] -> [Bool] -> [a]
task5 xs choice =
  map (\ ((f, s), c) -> if c then f else s) (zip xs choice)

--ex6
task6 :: Eq a => [a] -> [a]
task6 xs = [x | (x:_) <- group xs]

main :: IO()
main = do
  print $ task1 [(-1,1), (2,2), (0,-3)]
  print $ task2 "Hi how are you Today"
  print $ task3 8128
  print $ take 3 bonusTask3
  print $ task4 [1,2,1,3,1,4] 1
  print $ task5 [(0,1),(0,1),(0,1)] [True, False, True]
  print $ task6 [0,0,1,2,2,2,3,4]
  print $ task6' [0,0,1,2,2,2,3,4]